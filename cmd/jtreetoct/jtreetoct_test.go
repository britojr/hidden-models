package main

import (
	"reflect"
	"strings"
	"testing"
)

func TestParseToCT(t *testing.T) {
	cases := []struct {
		s            string
		cliques, adj [][]int
	}{{
		`BP::run:  converged in 92 passes (0.14036 seconds).
Initial clusters: ({x0, x20}, {x0, x21}, {x0, x22})
VarElim result: ({x0, x20, x21}, {x1, x20, x21}, {x2, x20, x21}, {x7, x20, x21}, {x18, x20, x21}, {x19, x20, x21})
Estimate of needed memory: 1966080kB
Maximum memory: unlimited
Spanning tree: ((0->1), (0->2), (2->4), (4->3), (4->5))
Regiongraph generated by JTree::GenerateJT: digraph RegionGraph {
node[shape=box];`,
		[][]int{
			{0, 20, 21},
			{1, 20, 21},
			{2, 20, 21},
			{7, 20, 21},
			{18, 20, 21},
			{19, 20, 21},
		},
		[][]int{
			{1, 2},
			{0},
			{0, 4},
			{4},
			{2, 3, 5},
			{4},
		},
	}}
	for _, tt := range cases {
		got := parseToCT(strings.NewReader(tt.s))
		if !reflect.DeepEqual(tt.cliques, got.Cliques()) {
			t.Errorf("wrong cliques %v != %v", tt.cliques, got.Cliques())
		}
		for i := range tt.adj {
			if !reflect.DeepEqual(tt.adj[i], got.Neighbours(i)) {
				t.Errorf("wrong cliques %v != %v", tt.adj[i], got.Neighbours(i))
			}
		}
	}
}

func TestFindLines(t *testing.T) {
	cases := []struct {
		s    string
		ps   []string
		want map[string]string
	}{{
		`BP::run:  converged in 92 passes (0.14036 seconds).
Initial clusters: ({x0, x20}, {x0, x21}, {x0, x22})
VarElim result: ({x0, x20, x21}, {x1, x20, x21}, {x2, x20, x21})
Estimate of needed memory: 1966080kB
Maximum memory: unlimited
Spanning tree: ((0->1), (0->2))
Regiongraph generated by JTree::GenerateJT: digraph RegionGraph {
node[shape=box];`,
		[]string{cliqueConst, edgesConst},
		map[string]string{
			cliqueConst: `VarElim result: ({x0, x20, x21}, {x1, x20, x21}, {x2, x20, x21})`,
			edgesConst:  `Spanning tree: ((0->1), (0->2))`,
		},
	}}
	for _, tt := range cases {
		got := findLines(strings.NewReader(tt.s), tt.ps)
		if !reflect.DeepEqual(tt.want, got) {
			t.Errorf("%v != %v", tt.want, got)
		}
	}
}

func TestParseClique(t *testing.T) {
	cases := []struct {
		s    string
		want [][]int
	}{{
		`VarElim result: ({x0, x20, x21}, {x1, x20, x21}, {x2, x20, x21})`,
		[][]int{
			{0, 20, 21},
			{1, 20, 21},
			{2, 20, 21},
		},
	}}
	for _, tt := range cases {
		got := parseClique(tt.s)
		if !reflect.DeepEqual(tt.want, got) {
			t.Errorf("%v != %v", tt.want, got)
		}
	}
}

func TestParseAdj(t *testing.T) {
	cases := []struct {
		s    string
		want [][]int
	}{{
		`Spanning tree: ((0->1), (0->2), (2->4), (4->3), (4->5))`,
		[][]int{
			{1, 2},
			{0},
			{0, 4},
			{4},
			{2, 3, 5},
			{4},
		},
	}}
	for _, tt := range cases {
		got := parseAdj(tt.s, len(tt.want))
		if !reflect.DeepEqual(tt.want, got) {
			t.Errorf("%v != %v", tt.want, got)
		}
	}
}
